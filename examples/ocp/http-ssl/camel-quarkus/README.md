## Securing Camel routes with TLS certificates using the cert-manager Operator for Red Hat OpenShift

In this sample you'll use the cert-manager Operator for Red Hat OpenShift to secure communication between two peers
(client and server) in OpenShift. 

There is an option to allow cert-manager operator to automatically create a certificate for a Ingress resource so there is a public secured HTTPS endpoint that forwards to the camel-quarkus-server.

### Prerequisites

- oc client [installed](https://docs.openshift.com/container-platform/latest/cli_reference/openshift_cli/getting-started-cli.htmlguide) to execute remote operations.
- already logged in into cluster (successfully running _oc login_)
- cert-manager Operator for Red Hat OpenShift [installed](https://docs.openshift.com/container-platform/latest/security/cert_manager_operator/cert-manager-operator-install.html) and configured correctly.

### Preparing the project

We'll connect to the `camel-http-ssl-qk` project and check the installation status. To change project, open a terminal tab and type the following command:

```
oc new-project camel-http-ssl-qk
```

### Create certificates

To set up the certificates and keystores, the cert-manager Operator need to be installed, please refer to the official guide linked above.

Once the operator is installed, you can create the issuer running
```
oc apply -f ../resources/issuer.yaml
```
then verify the issuer is ready (optional)
```
oc get issuers -n camel-http-ssl-qk
```
create secret containing password for the keys
```
oc create secret generic http-ssl-example-tls-password --from-literal=password=pass123
```

generate server certificate

```
oc apply -f ../resources/certificate-server.yaml
```

verify server certificate in the managed secret (optional)

```
oc get secret ocp-ssl-camel-server-tls
```

generate client certificate

```
oc apply -f ../resources/certificate-client.yaml
```

verify client certificate in the managed secret (optional)

```
oc get secret ocp-ssl-client-tls
```

create a role and role binding to access to the secrets, bound to the service account named `secret-reader` used to run applications

```
oc apply -f role.yaml
```

## Deploy to OCP

Deploy the server on OCP:

```
./mvnw install -Dquarkus.openshift.deploy=true -f server/pom.xml
```

Deploy client on OCP:

```
./mvnw install -Dquarkus.openshift.deploy=true -f client/pom.xml
```

to test the application, call the API exposed by the client, to start the handshake between client and server:

```
curl "http://$(oc get route camel-http-ssl-client -o go-template --template='{{.spec.host}}')/ping"
pong
```

### Use the ingress resource

This use case creates an `Ingress` resource with the `cert-manager.io/issuer: selfsigned-issuer` annotation that triggers the cert-manager operator to create a `Certificate` and associate it to the Ingress endpoint, so you don't have to manually create a `Certificate`. You can examine the `ingress.yaml` for details.

NOTE: Undeploy the client and server if you had deployed them, you can do it with `oc delete -f client/target/kubernetes/openshift.yml` and `oc delete -f server/target/kubernetes/openshift.yml`.

It uses a quarkus profile to select specific configurations for this deployment. In this case the pod and service runs in a non secure endpoint to a 8080 port. 
Then the Ingress resource is HTTPS enabled and connects to the service in 8080 port.

You can build and deploy the server with this command:
```
mvn package -Dquarkus.profile=public -Dquarkus.openshift.deploy=true -f server/pom.xml
```

If the build and deploy is successfull you can deploy the Ingress resource, but before that you must set the correct hostname in the `ingress.yaml` file located in the resources directory.

First, you have to know what is the domain name of your cluster, you can get it by examining the `ingresses.config/cluster` resource, like this:

```
echo camel-server.`oc get ingresses.config/cluster -o jsonpath={.spec.domain}`
```

Then you update the hosts in the `ingress.yaml` file.

There is a script to perform this automatically:

```
export my_host="camel-server."$(oc get ingresses.config/cluster -o jsonpath={.spec.domain})
sed -i "s/camel-server.my-domain/$my_host/g" resources/ingress.yaml
```

Then you can examine the creation of the `Certificate/gen-ocp-ssl-camel-server-tls`, `Secret/gen-ocp-ssl-camel-server-tls` and the `Ingress` kubernetes resources.

To test the application, call the server API, in this case skipping the certificate checks.
```
curl -k https://$(oc get ingress camel-http-ssl-server -ojsonpath='{.spec.rules[0].host}')/ping
```

If you want to use the certificate generated by cert-manager you can extract it from the `Secret` to a local file and use it with curl:

```
kubectl get secret gen-ocp-ssl-camel-server-tls  -o jsonpath="{.data.ca\.crt}" | base64 --decode > gen_ca.crt
```

Call the API endpoint with the CA certificate.
```
curl --cacert gen_ca.crt https://$(oc get ingress camel-http-ssl-server -ojsonpath='{.spec.rules[0].host}')/ping
```
